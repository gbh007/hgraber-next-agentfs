// Code generated by ogen, DO NOT EDIT.

package agentAPI

import (
	"math/bits"
	"net/url"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes APICoreStatusGetBadRequest as json.
func (s *APICoreStatusGetBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APICoreStatusGetBadRequest from json.
func (s *APICoreStatusGetBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APICoreStatusGetBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APICoreStatusGetBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APICoreStatusGetBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APICoreStatusGetBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APICoreStatusGetForbidden as json.
func (s *APICoreStatusGetForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APICoreStatusGetForbidden from json.
func (s *APICoreStatusGetForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APICoreStatusGetForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APICoreStatusGetForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APICoreStatusGetForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APICoreStatusGetForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APICoreStatusGetInternalServerError as json.
func (s *APICoreStatusGetInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APICoreStatusGetInternalServerError from json.
func (s *APICoreStatusGetInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APICoreStatusGetInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APICoreStatusGetInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APICoreStatusGetInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APICoreStatusGetInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APICoreStatusGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APICoreStatusGetOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("start_at")
		json.EncodeDateTime(e, s.StartAt)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Problems != nil {
			e.FieldStart("problems")
			e.ArrStart()
			for _, elem := range s.Problems {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAPICoreStatusGetOK = [3]string{
	0: "start_at",
	1: "status",
	2: "problems",
}

// Decode decodes APICoreStatusGetOK from json.
func (s *APICoreStatusGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APICoreStatusGetOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "start_at":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_at\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "problems":
			if err := func() error {
				s.Problems = make([]APICoreStatusGetOKProblemsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem APICoreStatusGetOKProblemsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Problems = append(s.Problems, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"problems\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APICoreStatusGetOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPICoreStatusGetOK) {
					name = jsonFieldsNameOfAPICoreStatusGetOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APICoreStatusGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APICoreStatusGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APICoreStatusGetOKProblemsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APICoreStatusGetOKProblemsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("details")
		e.Str(s.Details)
	}
}

var jsonFieldsNameOfAPICoreStatusGetOKProblemsItem = [2]string{
	0: "type",
	1: "details",
}

// Decode decodes APICoreStatusGetOKProblemsItem from json.
func (s *APICoreStatusGetOKProblemsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APICoreStatusGetOKProblemsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "details":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Details = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APICoreStatusGetOKProblemsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPICoreStatusGetOKProblemsItem) {
					name = jsonFieldsNameOfAPICoreStatusGetOKProblemsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APICoreStatusGetOKProblemsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APICoreStatusGetOKProblemsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APICoreStatusGetOKProblemsItemType as json.
func (s APICoreStatusGetOKProblemsItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes APICoreStatusGetOKProblemsItemType from json.
func (s *APICoreStatusGetOKProblemsItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APICoreStatusGetOKProblemsItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch APICoreStatusGetOKProblemsItemType(v) {
	case APICoreStatusGetOKProblemsItemTypeInfo:
		*s = APICoreStatusGetOKProblemsItemTypeInfo
	case APICoreStatusGetOKProblemsItemTypeWarning:
		*s = APICoreStatusGetOKProblemsItemTypeWarning
	case APICoreStatusGetOKProblemsItemTypeError:
		*s = APICoreStatusGetOKProblemsItemTypeError
	default:
		*s = APICoreStatusGetOKProblemsItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APICoreStatusGetOKProblemsItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APICoreStatusGetOKProblemsItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APICoreStatusGetOKStatus as json.
func (s APICoreStatusGetOKStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes APICoreStatusGetOKStatus from json.
func (s *APICoreStatusGetOKStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APICoreStatusGetOKStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch APICoreStatusGetOKStatus(v) {
	case APICoreStatusGetOKStatusOk:
		*s = APICoreStatusGetOKStatusOk
	case APICoreStatusGetOKStatusWarning:
		*s = APICoreStatusGetOKStatusWarning
	case APICoreStatusGetOKStatusError:
		*s = APICoreStatusGetOKStatusError
	default:
		*s = APICoreStatusGetOKStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APICoreStatusGetOKStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APICoreStatusGetOKStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APICoreStatusGetUnauthorized as json.
func (s *APICoreStatusGetUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APICoreStatusGetUnauthorized from json.
func (s *APICoreStatusGetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APICoreStatusGetUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APICoreStatusGetUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APICoreStatusGetUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APICoreStatusGetUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIExportArchivePostBadRequest as json.
func (s *APIExportArchivePostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIExportArchivePostBadRequest from json.
func (s *APIExportArchivePostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIExportArchivePostBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIExportArchivePostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIExportArchivePostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIExportArchivePostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIExportArchivePostForbidden as json.
func (s *APIExportArchivePostForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIExportArchivePostForbidden from json.
func (s *APIExportArchivePostForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIExportArchivePostForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIExportArchivePostForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIExportArchivePostForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIExportArchivePostForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIExportArchivePostInternalServerError as json.
func (s *APIExportArchivePostInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIExportArchivePostInternalServerError from json.
func (s *APIExportArchivePostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIExportArchivePostInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIExportArchivePostInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIExportArchivePostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIExportArchivePostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIExportArchivePostUnauthorized as json.
func (s *APIExportArchivePostUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIExportArchivePostUnauthorized from json.
func (s *APIExportArchivePostUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIExportArchivePostUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIExportArchivePostUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIExportArchivePostUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIExportArchivePostUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsCreatePostBadRequest as json.
func (s *APIFsCreatePostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsCreatePostBadRequest from json.
func (s *APIFsCreatePostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsCreatePostBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsCreatePostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsCreatePostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsCreatePostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsCreatePostConflict as json.
func (s *APIFsCreatePostConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsCreatePostConflict from json.
func (s *APIFsCreatePostConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsCreatePostConflict to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsCreatePostConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsCreatePostConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsCreatePostConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsCreatePostForbidden as json.
func (s *APIFsCreatePostForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsCreatePostForbidden from json.
func (s *APIFsCreatePostForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsCreatePostForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsCreatePostForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsCreatePostForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsCreatePostForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsCreatePostInternalServerError as json.
func (s *APIFsCreatePostInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsCreatePostInternalServerError from json.
func (s *APIFsCreatePostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsCreatePostInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsCreatePostInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsCreatePostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsCreatePostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsCreatePostUnauthorized as json.
func (s *APIFsCreatePostUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsCreatePostUnauthorized from json.
func (s *APIFsCreatePostUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsCreatePostUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsCreatePostUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsCreatePostUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsCreatePostUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsDeletePostBadRequest as json.
func (s *APIFsDeletePostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsDeletePostBadRequest from json.
func (s *APIFsDeletePostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsDeletePostBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsDeletePostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsDeletePostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsDeletePostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsDeletePostForbidden as json.
func (s *APIFsDeletePostForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsDeletePostForbidden from json.
func (s *APIFsDeletePostForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsDeletePostForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsDeletePostForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsDeletePostForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsDeletePostForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsDeletePostInternalServerError as json.
func (s *APIFsDeletePostInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsDeletePostInternalServerError from json.
func (s *APIFsDeletePostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsDeletePostInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsDeletePostInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsDeletePostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsDeletePostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsDeletePostNotFound as json.
func (s *APIFsDeletePostNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsDeletePostNotFound from json.
func (s *APIFsDeletePostNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsDeletePostNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsDeletePostNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsDeletePostNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsDeletePostNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIFsDeletePostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIFsDeletePostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		json.EncodeUUID(e, s.FileID)
	}
}

var jsonFieldsNameOfAPIFsDeletePostReq = [1]string{
	0: "file_id",
}

// Decode decodes APIFsDeletePostReq from json.
func (s *APIFsDeletePostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsDeletePostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.FileID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIFsDeletePostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIFsDeletePostReq) {
					name = jsonFieldsNameOfAPIFsDeletePostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsDeletePostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsDeletePostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsDeletePostUnauthorized as json.
func (s *APIFsDeletePostUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsDeletePostUnauthorized from json.
func (s *APIFsDeletePostUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsDeletePostUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsDeletePostUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsDeletePostUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsDeletePostUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsGetGetBadRequest as json.
func (s *APIFsGetGetBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsGetGetBadRequest from json.
func (s *APIFsGetGetBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsGetGetBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsGetGetBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsGetGetBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsGetGetBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsGetGetForbidden as json.
func (s *APIFsGetGetForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsGetGetForbidden from json.
func (s *APIFsGetGetForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsGetGetForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsGetGetForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsGetGetForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsGetGetForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsGetGetInternalServerError as json.
func (s *APIFsGetGetInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsGetGetInternalServerError from json.
func (s *APIFsGetGetInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsGetGetInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsGetGetInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsGetGetInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsGetGetInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsGetGetNotFound as json.
func (s *APIFsGetGetNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsGetGetNotFound from json.
func (s *APIFsGetGetNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsGetGetNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsGetGetNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsGetGetNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsGetGetNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsGetGetUnauthorized as json.
func (s *APIFsGetGetUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsGetGetUnauthorized from json.
func (s *APIFsGetGetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsGetGetUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsGetGetUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsGetGetUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsGetGetUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsIdsGetBadRequest as json.
func (s *APIFsIdsGetBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsIdsGetBadRequest from json.
func (s *APIFsIdsGetBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsIdsGetBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsIdsGetBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsIdsGetBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsIdsGetBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsIdsGetForbidden as json.
func (s *APIFsIdsGetForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsIdsGetForbidden from json.
func (s *APIFsIdsGetForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsIdsGetForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsIdsGetForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsIdsGetForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsIdsGetForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsIdsGetInternalServerError as json.
func (s *APIFsIdsGetInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsIdsGetInternalServerError from json.
func (s *APIFsIdsGetInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsIdsGetInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsIdsGetInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsIdsGetInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsIdsGetInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsIdsGetOKApplicationJSON as json.
func (s APIFsIdsGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []uuid.UUID(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		json.EncodeUUID(e, elem)
	}
	e.ArrEnd()
}

// Decode decodes APIFsIdsGetOKApplicationJSON from json.
func (s *APIFsIdsGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsIdsGetOKApplicationJSON to nil")
	}
	var unwrapped []uuid.UUID
	if err := func() error {
		unwrapped = make([]uuid.UUID, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem uuid.UUID
			v, err := json.DecodeUUID(d)
			elem = v
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsIdsGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIFsIdsGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsIdsGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIFsIdsGetUnauthorized as json.
func (s *APIFsIdsGetUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIFsIdsGetUnauthorized from json.
func (s *APIFsIdsGetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIFsIdsGetUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIFsIdsGetUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIFsIdsGetUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIFsIdsGetUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingBookCheckPostBadRequest as json.
func (s *APIParsingBookCheckPostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingBookCheckPostBadRequest from json.
func (s *APIParsingBookCheckPostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingBookCheckPostBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingBookCheckPostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingBookCheckPostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingBookCheckPostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingBookCheckPostForbidden as json.
func (s *APIParsingBookCheckPostForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingBookCheckPostForbidden from json.
func (s *APIParsingBookCheckPostForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingBookCheckPostForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingBookCheckPostForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingBookCheckPostForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingBookCheckPostForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingBookCheckPostInternalServerError as json.
func (s *APIParsingBookCheckPostInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingBookCheckPostInternalServerError from json.
func (s *APIParsingBookCheckPostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingBookCheckPostInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingBookCheckPostInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingBookCheckPostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingBookCheckPostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIParsingBookCheckPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIParsingBookCheckPostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("urls")
		e.ArrStart()
		for _, elem := range s.Urls {
			json.EncodeURI(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAPIParsingBookCheckPostReq = [1]string{
	0: "urls",
}

// Decode decodes APIParsingBookCheckPostReq from json.
func (s *APIParsingBookCheckPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingBookCheckPostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "urls":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Urls = make([]url.URL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem url.URL
					v, err := json.DecodeURI(d)
					elem = v
					if err != nil {
						return err
					}
					s.Urls = append(s.Urls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"urls\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIParsingBookCheckPostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIParsingBookCheckPostReq) {
					name = jsonFieldsNameOfAPIParsingBookCheckPostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingBookCheckPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingBookCheckPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingBookCheckPostUnauthorized as json.
func (s *APIParsingBookCheckPostUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingBookCheckPostUnauthorized from json.
func (s *APIParsingBookCheckPostUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingBookCheckPostUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingBookCheckPostUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingBookCheckPostUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingBookCheckPostUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingBookMultiPostBadRequest as json.
func (s *APIParsingBookMultiPostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingBookMultiPostBadRequest from json.
func (s *APIParsingBookMultiPostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingBookMultiPostBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingBookMultiPostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingBookMultiPostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingBookMultiPostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingBookMultiPostForbidden as json.
func (s *APIParsingBookMultiPostForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingBookMultiPostForbidden from json.
func (s *APIParsingBookMultiPostForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingBookMultiPostForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingBookMultiPostForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingBookMultiPostForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingBookMultiPostForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingBookMultiPostInternalServerError as json.
func (s *APIParsingBookMultiPostInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingBookMultiPostInternalServerError from json.
func (s *APIParsingBookMultiPostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingBookMultiPostInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingBookMultiPostInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingBookMultiPostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingBookMultiPostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIParsingBookMultiPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIParsingBookMultiPostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfAPIParsingBookMultiPostReq = [1]string{
	0: "url",
}

// Decode decodes APIParsingBookMultiPostReq from json.
func (s *APIParsingBookMultiPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingBookMultiPostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIParsingBookMultiPostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIParsingBookMultiPostReq) {
					name = jsonFieldsNameOfAPIParsingBookMultiPostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingBookMultiPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingBookMultiPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingBookMultiPostUnauthorized as json.
func (s *APIParsingBookMultiPostUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingBookMultiPostUnauthorized from json.
func (s *APIParsingBookMultiPostUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingBookMultiPostUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingBookMultiPostUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingBookMultiPostUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingBookMultiPostUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingBookPostBadRequest as json.
func (s *APIParsingBookPostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingBookPostBadRequest from json.
func (s *APIParsingBookPostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingBookPostBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingBookPostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingBookPostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingBookPostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingBookPostForbidden as json.
func (s *APIParsingBookPostForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingBookPostForbidden from json.
func (s *APIParsingBookPostForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingBookPostForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingBookPostForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingBookPostForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingBookPostForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingBookPostInternalServerError as json.
func (s *APIParsingBookPostInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingBookPostInternalServerError from json.
func (s *APIParsingBookPostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingBookPostInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingBookPostInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingBookPostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingBookPostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIParsingBookPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIParsingBookPostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfAPIParsingBookPostReq = [1]string{
	0: "url",
}

// Decode decodes APIParsingBookPostReq from json.
func (s *APIParsingBookPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingBookPostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIParsingBookPostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIParsingBookPostReq) {
					name = jsonFieldsNameOfAPIParsingBookPostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingBookPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingBookPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingBookPostUnauthorized as json.
func (s *APIParsingBookPostUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingBookPostUnauthorized from json.
func (s *APIParsingBookPostUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingBookPostUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingBookPostUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingBookPostUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingBookPostUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingPageCheckPostBadRequest as json.
func (s *APIParsingPageCheckPostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingPageCheckPostBadRequest from json.
func (s *APIParsingPageCheckPostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingPageCheckPostBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingPageCheckPostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingPageCheckPostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingPageCheckPostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingPageCheckPostForbidden as json.
func (s *APIParsingPageCheckPostForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingPageCheckPostForbidden from json.
func (s *APIParsingPageCheckPostForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingPageCheckPostForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingPageCheckPostForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingPageCheckPostForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingPageCheckPostForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingPageCheckPostInternalServerError as json.
func (s *APIParsingPageCheckPostInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingPageCheckPostInternalServerError from json.
func (s *APIParsingPageCheckPostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingPageCheckPostInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingPageCheckPostInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingPageCheckPostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingPageCheckPostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIParsingPageCheckPostOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIParsingPageCheckPostOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("result")
		e.ArrStart()
		for _, elem := range s.Result {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAPIParsingPageCheckPostOK = [1]string{
	0: "result",
}

// Decode decodes APIParsingPageCheckPostOK from json.
func (s *APIParsingPageCheckPostOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingPageCheckPostOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Result = make([]APIParsingPageCheckPostOKResultItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem APIParsingPageCheckPostOKResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIParsingPageCheckPostOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIParsingPageCheckPostOK) {
					name = jsonFieldsNameOfAPIParsingPageCheckPostOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingPageCheckPostOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingPageCheckPostOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIParsingPageCheckPostOKResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIParsingPageCheckPostOKResultItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("book_url")
		json.EncodeURI(e, s.BookURL)
	}
	{
		e.FieldStart("image_url")
		json.EncodeURI(e, s.ImageURL)
	}
	{
		e.FieldStart("result")
		s.Result.Encode(e)
	}
	{
		if s.ErrorDetails.Set {
			e.FieldStart("error_details")
			s.ErrorDetails.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIParsingPageCheckPostOKResultItem = [4]string{
	0: "book_url",
	1: "image_url",
	2: "result",
	3: "error_details",
}

// Decode decodes APIParsingPageCheckPostOKResultItem from json.
func (s *APIParsingPageCheckPostOKResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingPageCheckPostOKResultItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "book_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.BookURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"book_url\"")
			}
		case "image_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ImageURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_url\"")
			}
		case "result":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "error_details":
			if err := func() error {
				s.ErrorDetails.Reset()
				if err := s.ErrorDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIParsingPageCheckPostOKResultItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIParsingPageCheckPostOKResultItem) {
					name = jsonFieldsNameOfAPIParsingPageCheckPostOKResultItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingPageCheckPostOKResultItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingPageCheckPostOKResultItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingPageCheckPostOKResultItemResult as json.
func (s APIParsingPageCheckPostOKResultItemResult) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes APIParsingPageCheckPostOKResultItemResult from json.
func (s *APIParsingPageCheckPostOKResultItemResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingPageCheckPostOKResultItemResult to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch APIParsingPageCheckPostOKResultItemResult(v) {
	case APIParsingPageCheckPostOKResultItemResultOk:
		*s = APIParsingPageCheckPostOKResultItemResultOk
	case APIParsingPageCheckPostOKResultItemResultUnsupported:
		*s = APIParsingPageCheckPostOKResultItemResultUnsupported
	case APIParsingPageCheckPostOKResultItemResultError:
		*s = APIParsingPageCheckPostOKResultItemResultError
	default:
		*s = APIParsingPageCheckPostOKResultItemResult(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIParsingPageCheckPostOKResultItemResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingPageCheckPostOKResultItemResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIParsingPageCheckPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIParsingPageCheckPostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("urls")
		e.ArrStart()
		for _, elem := range s.Urls {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAPIParsingPageCheckPostReq = [1]string{
	0: "urls",
}

// Decode decodes APIParsingPageCheckPostReq from json.
func (s *APIParsingPageCheckPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingPageCheckPostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "urls":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Urls = make([]APIParsingPageCheckPostReqUrlsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem APIParsingPageCheckPostReqUrlsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Urls = append(s.Urls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"urls\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIParsingPageCheckPostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIParsingPageCheckPostReq) {
					name = jsonFieldsNameOfAPIParsingPageCheckPostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingPageCheckPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingPageCheckPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIParsingPageCheckPostReqUrlsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIParsingPageCheckPostReqUrlsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("book_url")
		json.EncodeURI(e, s.BookURL)
	}
	{
		e.FieldStart("image_url")
		json.EncodeURI(e, s.ImageURL)
	}
}

var jsonFieldsNameOfAPIParsingPageCheckPostReqUrlsItem = [2]string{
	0: "book_url",
	1: "image_url",
}

// Decode decodes APIParsingPageCheckPostReqUrlsItem from json.
func (s *APIParsingPageCheckPostReqUrlsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingPageCheckPostReqUrlsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "book_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.BookURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"book_url\"")
			}
		case "image_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ImageURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIParsingPageCheckPostReqUrlsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIParsingPageCheckPostReqUrlsItem) {
					name = jsonFieldsNameOfAPIParsingPageCheckPostReqUrlsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingPageCheckPostReqUrlsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingPageCheckPostReqUrlsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingPageCheckPostUnauthorized as json.
func (s *APIParsingPageCheckPostUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingPageCheckPostUnauthorized from json.
func (s *APIParsingPageCheckPostUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingPageCheckPostUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingPageCheckPostUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingPageCheckPostUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingPageCheckPostUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingPagePostBadRequest as json.
func (s *APIParsingPagePostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingPagePostBadRequest from json.
func (s *APIParsingPagePostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingPagePostBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingPagePostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingPagePostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingPagePostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingPagePostForbidden as json.
func (s *APIParsingPagePostForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingPagePostForbidden from json.
func (s *APIParsingPagePostForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingPagePostForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingPagePostForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingPagePostForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingPagePostForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingPagePostInternalServerError as json.
func (s *APIParsingPagePostInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingPagePostInternalServerError from json.
func (s *APIParsingPagePostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingPagePostInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingPagePostInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingPagePostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingPagePostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIParsingPagePostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIParsingPagePostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("book_url")
		json.EncodeURI(e, s.BookURL)
	}
	{
		e.FieldStart("image_url")
		json.EncodeURI(e, s.ImageURL)
	}
}

var jsonFieldsNameOfAPIParsingPagePostReq = [2]string{
	0: "book_url",
	1: "image_url",
}

// Decode decodes APIParsingPagePostReq from json.
func (s *APIParsingPagePostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingPagePostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "book_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.BookURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"book_url\"")
			}
		case "image_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ImageURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIParsingPagePostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIParsingPagePostReq) {
					name = jsonFieldsNameOfAPIParsingPagePostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingPagePostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingPagePostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIParsingPagePostUnauthorized as json.
func (s *APIParsingPagePostUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIParsingPagePostUnauthorized from json.
func (s *APIParsingPagePostUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIParsingPagePostUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIParsingPagePostUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIParsingPagePostUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIParsingPagePostUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BookDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BookDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("page_count")
		e.Int(s.PageCount)
	}
	{
		e.FieldStart("attributes")
		e.ArrStart()
		for _, elem := range s.Attributes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("pages")
		e.ArrStart()
		for _, elem := range s.Pages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBookDetails = [5]string{
	0: "url",
	1: "name",
	2: "page_count",
	3: "attributes",
	4: "pages",
}

// Decode decodes BookDetails from json.
func (s *BookDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BookDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "page_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.PageCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_count\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Attributes = make([]BookDetailsAttributesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BookDetailsAttributesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Attributes = append(s.Attributes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "pages":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Pages = make([]BookDetailsPagesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BookDetailsPagesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Pages = append(s.Pages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BookDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBookDetails) {
					name = jsonFieldsNameOfBookDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BookDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BookDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BookDetailsAttributesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BookDetailsAttributesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		s.Code.Encode(e)
	}
	{
		e.FieldStart("values")
		e.ArrStart()
		for _, elem := range s.Values {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBookDetailsAttributesItem = [2]string{
	0: "code",
	1: "values",
}

// Decode decodes BookDetailsAttributesItem from json.
func (s *BookDetailsAttributesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BookDetailsAttributesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "values":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BookDetailsAttributesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBookDetailsAttributesItem) {
					name = jsonFieldsNameOfBookDetailsAttributesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BookDetailsAttributesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BookDetailsAttributesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BookDetailsAttributesItemCode as json.
func (s BookDetailsAttributesItemCode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BookDetailsAttributesItemCode from json.
func (s *BookDetailsAttributesItemCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BookDetailsAttributesItemCode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BookDetailsAttributesItemCode(v) {
	case BookDetailsAttributesItemCodeAuthor:
		*s = BookDetailsAttributesItemCodeAuthor
	case BookDetailsAttributesItemCodeCategory:
		*s = BookDetailsAttributesItemCodeCategory
	case BookDetailsAttributesItemCodeCharacter:
		*s = BookDetailsAttributesItemCodeCharacter
	case BookDetailsAttributesItemCodeGroup:
		*s = BookDetailsAttributesItemCodeGroup
	case BookDetailsAttributesItemCodeLanguage:
		*s = BookDetailsAttributesItemCodeLanguage
	case BookDetailsAttributesItemCodeParody:
		*s = BookDetailsAttributesItemCodeParody
	case BookDetailsAttributesItemCodeTag:
		*s = BookDetailsAttributesItemCodeTag
	default:
		*s = BookDetailsAttributesItemCode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BookDetailsAttributesItemCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BookDetailsAttributesItemCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BookDetailsPagesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BookDetailsPagesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("page_number")
		e.Int(s.PageNumber)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("filename")
		e.Str(s.Filename)
	}
}

var jsonFieldsNameOfBookDetailsPagesItem = [3]string{
	0: "page_number",
	1: "url",
	2: "filename",
}

// Decode decodes BookDetailsPagesItem from json.
func (s *BookDetailsPagesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BookDetailsPagesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page_number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.PageNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_number\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "filename":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Filename = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BookDetailsPagesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBookDetailsPagesItem) {
					name = jsonFieldsNameOfBookDetailsPagesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BookDetailsPagesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BookDetailsPagesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BooksCheckResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BooksCheckResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("result")
		e.ArrStart()
		for _, elem := range s.Result {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBooksCheckResult = [1]string{
	0: "result",
}

// Decode decodes BooksCheckResult from json.
func (s *BooksCheckResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BooksCheckResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Result = make([]BooksCheckResultResultItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BooksCheckResultResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BooksCheckResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBooksCheckResult) {
					name = jsonFieldsNameOfBooksCheckResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BooksCheckResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BooksCheckResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BooksCheckResultResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BooksCheckResultResultItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("result")
		s.Result.Encode(e)
	}
	{
		if s.ErrorDetails.Set {
			e.FieldStart("error_details")
			s.ErrorDetails.Encode(e)
		}
	}
	{
		if s.PossibleDuplicates != nil {
			e.FieldStart("possible_duplicates")
			e.ArrStart()
			for _, elem := range s.PossibleDuplicates {
				json.EncodeURI(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBooksCheckResultResultItem = [4]string{
	0: "url",
	1: "result",
	2: "error_details",
	3: "possible_duplicates",
}

// Decode decodes BooksCheckResultResultItem from json.
func (s *BooksCheckResultResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BooksCheckResultResultItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "result":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "error_details":
			if err := func() error {
				s.ErrorDetails.Reset()
				if err := s.ErrorDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_details\"")
			}
		case "possible_duplicates":
			if err := func() error {
				s.PossibleDuplicates = make([]url.URL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem url.URL
					v, err := json.DecodeURI(d)
					elem = v
					if err != nil {
						return err
					}
					s.PossibleDuplicates = append(s.PossibleDuplicates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"possible_duplicates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BooksCheckResultResultItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBooksCheckResultResultItem) {
					name = jsonFieldsNameOfBooksCheckResultResultItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BooksCheckResultResultItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BooksCheckResultResultItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BooksCheckResultResultItemResult as json.
func (s BooksCheckResultResultItemResult) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BooksCheckResultResultItemResult from json.
func (s *BooksCheckResultResultItemResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BooksCheckResultResultItemResult to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BooksCheckResultResultItemResult(v) {
	case BooksCheckResultResultItemResultOk:
		*s = BooksCheckResultResultItemResultOk
	case BooksCheckResultResultItemResultUnsupported:
		*s = BooksCheckResultResultItemResultUnsupported
	case BooksCheckResultResultItemResultError:
		*s = BooksCheckResultResultItemResultError
	default:
		*s = BooksCheckResultResultItemResult(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BooksCheckResultResultItemResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BooksCheckResultResultItemResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("inner_code")
		e.Str(s.InnerCode)
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrorResponse = [2]string{
	0: "inner_code",
	1: "details",
}

// Decode decodes ErrorResponse from json.
func (s *ErrorResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inner_code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.InnerCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inner_code\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrorResponse) {
					name = jsonFieldsNameOfErrorResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
